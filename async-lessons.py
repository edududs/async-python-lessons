import asyncio
import random
import secrets
from time import perf_counter


async def fetch_data(name: str, delay: float) -> dict:
    # Simulate I/O waiting for delay
    await asyncio.sleep(delay)
    data = secrets.token_hex(16)
    print(f"{name} ok in {delay:.1f}s")
    return {"data": data}


# ===============================
#            Basic tasks
# ===============================


async def basic_tasks():
    init = perf_counter()

    # Execute 3 concurrent tasks (single-thread, cooperative)
    results = await asyncio.gather(
        fetch_data("A", 1.0),
        fetch_data("B", 2.0),
        fetch_data("C", 1.5),
    )

    # Wait for all tasks to complete

    duration = perf_counter() - init
    print(results)
    for result in results:
        print(f"Received result: {result}")
    print(f"Total: {duration:.2f}s (deveria ser ~2.0s, n√£o 1.0+2.0+1.5)")


# ===============================
#            Task Groups
# ===============================


class TaskGroupExamples:
    """Demonstra diferentes cen√°rios de uso do asyncio.TaskGroup."""

    @staticmethod
    async def basic_task_group():
        """Exemplo b√°sico de TaskGroup com nomes aleat√≥rios."""
        init = perf_counter()
        tasks = []

        async with asyncio.TaskGroup() as tg:
            # Criar listas e embaralhar aleatoriamente
            nomes = ["laranja", "macaco", "banana", "casa"]
            tempos = [1.0, 2.0, 1.5, 4.0]
            random.shuffle(nomes)

            for nome, sleep_time in zip(nomes, tempos, strict=False):
                task = tg.create_task(fetch_data(nome, sleep_time))
                tasks.append(task)

        results = [task.result() for task in tasks]
        print(f"üìä Resultados: {results}")
        for result in results:
            print(f"üìã Resultado recebido: {result}")

        duration = perf_counter() - init
        print(f"‚è±Ô∏è  Total: {duration:.2f}s (deveria ser ~4.0s, n√£o 1.0+2.0+1.5+4.0)")
        return results

    @staticmethod
    async def task_group_with_error_handling():
        """TaskGroup com tratamento de erros e exce√ß√µes."""
        init = perf_counter()
        print("\nüîÑ TaskGroup com tratamento de erros...")

        async def fetch_with_retry(name: str, delay: float, fail_chance: float = 0.3):
            """Simula fetch com possibilidade de falha."""
            await asyncio.sleep(delay)
            if random.random() < fail_chance:
                raise Exception(f"Falha simulada para {name}")
            return {"data": f"Sucesso para {name}", "delay": delay}

        try:
            async with asyncio.TaskGroup() as tg:
                # Algumas tasks podem falhar
                tg.create_task(fetch_with_retry("A", 1.0, 0.1))
                tg.create_task(fetch_with_retry("B", 1.5, 0.5))
                tg.create_task(fetch_with_retry("C", 2.0, 0.2))
                tg.create_task(fetch_with_retry("D", 0.5, 0.8))

                print("üöÄ Tasks criadas, aguardando conclus√£o...")

        except Exception as e:
            print(f"‚ùå Alguma task falhou: {e}")

        duration = perf_counter() - init
        print(f"‚è±Ô∏è  Tempo total: {duration:.2f}s")
        return duration

    @staticmethod
    async def task_group_with_timeout():
        """TaskGroup com timeout global para todas as tasks."""
        init = perf_counter()
        print("\n‚è∞ TaskGroup com timeout global...")

        try:
            async with asyncio.timeout(2.5):  # Timeout global de 2.5s
                async with asyncio.TaskGroup() as tg:
                    # Tasks com diferentes dura√ß√µes
                    tg.create_task(fetch_data("R√°pida", 0.5))
                    tg.create_task(fetch_data("M√©dia", 1.5))
                    tg.create_task(fetch_data("Lenta", 3.0))  # Vai falhar por timeout
                    tg.create_task(
                        fetch_data("Muito Lenta", 4.0),
                    )  # Vai falhar por timeout

                    print("üöÄ Tasks criadas com timeout de 2.5s...")
                    await asyncio.sleep(0.1)  # Checkpoint para o cancellation scope

        except TimeoutError:
            print("‚è∞ Timeout global atingido! Algumas tasks foram canceladas.")

        duration = perf_counter() - init
        print(f"‚è±Ô∏è  Tempo total: {duration:.2f}s")
        return duration

    @staticmethod
    async def task_group_with_conditional_tasks():
        """TaskGroup que cria tasks condicionalmente baseado em resultados."""
        init = perf_counter()
        print("\nüéØ TaskGroup com tasks condicionais...")

        async def check_condition(name: str) -> bool:
            """Simula verifica√ß√£o de condi√ß√£o."""
            await asyncio.sleep(0.5)
            return random.choice([True, False])

        async def process_if_valid(name: str):
            """Processa apenas se a condi√ß√£o for v√°lida."""
            await asyncio.sleep(1.0)
            return f"Processado: {name}"

        results = []
        async with asyncio.TaskGroup() as tg:
            # Primeira fase: verificar condi√ß√µes
            condition_tasks = []
            for name in ["Item1", "Item2", "Item3", "Item4"]:
                task = tg.create_task(check_condition(name))
                condition_tasks.append((name, task))

            # Segunda fase: processar apenas os v√°lidos
            process_tasks = []
            for name, condition_task in condition_tasks:
                is_valid = await condition_task
                if is_valid:
                    print(f"‚úÖ {name} √© v√°lido, criando task de processamento...")
                    process_task = tg.create_task(process_if_valid(name))
                    process_tasks.append(process_task)
                else:
                    print(f"‚ùå {name} n√£o √© v√°lido, pulando...")

            # Coletar resultados
            for task in process_tasks:
                result = await task
                results.append(result)

        duration = perf_counter() - init
        print(f"üìä Resultados finais: {results}")
        print(f"‚è±Ô∏è  Tempo total: {duration:.2f}s")
        return results

    @staticmethod
    async def task_group_with_resource_limiting():
        """TaskGroup com limita√ß√£o de recursos (sem√°foro)."""
        init = perf_counter()
        print("\nüîí TaskGroup com limita√ß√£o de recursos...")

        # Sem√°foro limita a 2 tasks simult√¢neas
        semaphore = asyncio.Semaphore(2)

        async def fetch_with_semaphore(name: str, delay: float):
            """Fetch com controle de recursos via sem√°foro."""
            async with semaphore:
                print(f"üîì {name} adquiriu sem√°foro")
                await asyncio.sleep(delay)
                print(f"üîì {name} liberou sem√°foro")
                return {"data": f"Dados de {name}", "delay": delay}

        results = []
        async with asyncio.TaskGroup() as tg:
            # Criar 6 tasks, mas apenas 2 podem rodar simultaneamente
            for i in range(6):
                task = tg.create_task(
                    fetch_with_semaphore(f"Task{i + 1}", 1.0 + i * 0.2),
                )
                results.append(task)

            print("üöÄ 6 tasks criadas com sem√°foro limitando a 2 simult√¢neas...")

        # Coletar resultados
        final_results = [task.result() for task in results]
        duration = perf_counter() - init
        print(f"üìä Resultados: {final_results}")
        print(f"‚è±Ô∏è  Tempo total: {duration:.2f}s")
        return final_results


async def task_groups():
    """Executa todos os exemplos de TaskGroup."""
    print("üöÄ DEMONSTRANDO TASK GROUPS...")
    print("=" * 50)

    # Executar todos os exemplos
    await TaskGroupExamples.basic_task_group()
    await TaskGroupExamples.task_group_with_error_handling()
    await TaskGroupExamples.task_group_with_timeout()
    await TaskGroupExamples.task_group_with_conditional_tasks()
    await TaskGroupExamples.task_group_with_resource_limiting()

    print("=" * 50)
    print("‚úÖ Todos os exemplos de TaskGroup conclu√≠dos!")


# ===============================
#            Future
# ===============================


class FutureSimulator:
    """Encapsula opera√ß√µes ass√≠ncronas para resolver ou falhar um Future."""

    @staticmethod
    async def set_result(future: asyncio.Future, result: str):
        """Simula uma opera√ß√£o ass√≠ncrona que resolve um Future."""
        await asyncio.sleep(2)
        future.set_result(result)
        print(f"‚úÖ Future resolvido com resultado: '{result}'")

    @staticmethod
    async def set_exception(future: asyncio.Future, error_msg: str):
        """Simula uma opera√ß√£o que falha e define uma exce√ß√£o no Future."""
        await asyncio.sleep(1.5)
        future.set_exception(Exception(error_msg))
        print(f"‚ùå Future falhou com exce√ß√£o: '{error_msg}'")


class FutureDemoCases:
    """Encapsula demonstra√ß√µes de uso de asyncio.Future."""

    @staticmethod
    async def demonstrate_basic_future_success(event_loop):
        """Demonstra um Future b√°sico resolvido com sucesso."""
        print("\nüìã Caso 1: Future com resultado bem-sucedido")
        future_result = event_loop.create_future()
        resolve_task = event_loop.create_task(
            FutureSimulator.set_result(
                future_result,
                "Opera√ß√£o conclu√≠da com sucesso!",
            ),
        )
        print(f"Task 1: {resolve_task}")

        try:
            result_value = await future_result
            print(f"üéØ Resultado recebido: {result_value}")
        except Exception as exc:
            print(f"‚ùå Erro inesperado: {exc}")

    @staticmethod
    async def demonstrate_future_with_exception(event_loop):
        """Demonstra um Future que termina com exce√ß√£o."""
        print("\nüìã Caso 2: Future com falha/exce√ß√£o")
        future_result = event_loop.create_future()
        exception_task = event_loop.create_task(
            FutureSimulator.set_exception(
                future_result,
                "Erro de conex√£o com banco de dados",
            ),
        )
        print(f"Task 2: {exception_task}")

        try:
            result_value = await future_result
            print(f"üéØ Resultado recebido: {result_value}")
        except Exception as exc:
            print(f"‚ùå Exce√ß√£o capturada: {exc}")

    @staticmethod
    async def demonstrate_future_with_timeout(event_loop):
        """Demonstra um Future que excede o tempo limite (timeout)."""
        print("\nüìã Caso 3: Future com timeout")
        future_result = event_loop.create_future()
        delayed_task = event_loop.create_task(
            FutureSimulator.set_result(future_result, "Resultado tardio"),
        )

        try:
            result_value = await asyncio.wait_for(future_result, timeout=1.0)
            print(f"üéØ Resultado recebido: {result_value}")
        except TimeoutError:
            print("‚è∞ Timeout! Future n√£o foi resolvido a tempo")
            delayed_task.cancel()

    @staticmethod
    async def demonstrate_future_with_callback(event_loop):
        """Demonstra um Future com callback de conclus√£o."""
        print("\nüìã Caso 4: Future com callback de conclus√£o")
        future_result = event_loop.create_future()

        def on_future_done(completed_future):
            if completed_future.done():
                if completed_future.exception():
                    print(
                        f"üîî Callback: Future falhou com {completed_future.exception()}",
                    )
                else:
                    print(
                        f"üîî Callback: Future conclu√≠do com {completed_future.result()}",
                    )

        future_result.add_done_callback(on_future_done)
        callback_task = event_loop.create_task(
            FutureSimulator.set_result(future_result, "Future com callback!"),
        )
        print(f"Task 3: {callback_task}")
        await asyncio.sleep(0.1)

    @staticmethod
    async def demonstrate_multiple_futures_with_gather(event_loop):
        """Demonstra m√∫ltiplos Futures resolvidos em paralelo usando gather."""
        print("\nüìã Caso 5: M√∫ltiplos Futures com gather")
        future_list = []
        for idx in range(3):
            future_result = event_loop.create_future()
            future_list.append(future_result)
            gather_task = event_loop.create_task(
                FutureSimulator.set_result(future_result, f"Resultado {idx + 1}"),
            )
            print(f"Task 4: {gather_task}")

        all_results = await asyncio.gather(*future_list, return_exceptions=True)
        print(f"üéØ Todos os futures resolvidos: {all_results}")
        return all_results


async def main_future():
    """Demonstra os benef√≠cios e casos de uso do Future."""
    init = perf_counter()
    print("üöÄ Demonstrando Futures em asyncio...")
    print("=" * 50)

    loop = asyncio.get_running_loop()

    await FutureDemoCases.demonstrate_basic_future_success(loop)
    await FutureDemoCases.demonstrate_future_with_exception(loop)
    await FutureDemoCases.demonstrate_future_with_timeout(loop)
    await FutureDemoCases.demonstrate_future_with_callback(loop)
    results = await FutureDemoCases.demonstrate_multiple_futures_with_gather(loop)

    duration = perf_counter() - init
    print(f"\n‚è±Ô∏è  Tempo total: {duration:.2f}s")
    print("=" * 50)

    demonstrate_future_benefits()
    return results


def demonstrate_future_benefits():
    """Explica por que usar Futures."""
    print("\nüí° BENEF√çCIOS DOS FUTURES:")
    print("1. Controle manual sobre quando e como resolver opera√ß√µes ass√≠ncronas")
    print("2. Possibilidade de cancelar opera√ß√µes em andamento")
    print("3. Tratamento de exce√ß√µes personalizado")
    print("4. Callbacks para rea√ß√µes autom√°ticas quando opera√ß√µes terminam")
    print("5. Timeouts configur√°veis")
    print("6. Composi√ß√£o de m√∫ltiplas opera√ß√µes ass√≠ncronas")
    print("7. Separa√ß√£o entre cria√ß√£o e execu√ß√£o de opera√ß√µes")
    print("8. √ötil para APIs que precisam de controle granular sobre opera√ß√µes")


# ===============================
#            Locks
# ===============================


class AsyncLockExamples:
    """Demonstra diferentes tipos de locks e sincroniza√ß√£o em asyncio."""

    @staticmethod
    async def basic_lock_example():
        """Exemplo b√°sico de Lock para acesso exclusivo a um recurso."""
        print("\nüîí Exemplo b√°sico de Lock...")

        # Recurso compartilhado
        shared_counter = 0
        lock = asyncio.Lock()

        async def increment_with_lock(name: str, delay: float):
            """Incrementa o contador com lock exclusivo."""
            nonlocal shared_counter
            async with lock:
                print(f"üîì {name} adquiriu o lock")
                current = shared_counter
                await asyncio.sleep(delay)  # Simula trabalho
                shared_counter = current + 1
                print(f"üîì {name} liberou o lock, contador: {shared_counter}")

        # Executar m√∫ltiplas tasks concorrentes
        async with asyncio.TaskGroup() as tg:
            tg.create_task(increment_with_lock("Task A", 0.5))
            tg.create_task(increment_with_lock("Task B", 0.3))
            tg.create_task(increment_with_lock("Task C", 0.7))
            tg.create_task(increment_with_lock("Task D", 0.2))

        print(f"üìä Contador final: {shared_counter}")
        return shared_counter

    @staticmethod
    async def rlock_example():
        """Exemplo de RLock (Reentrant Lock) para fun√ß√µes recursivas."""
        print("\nüîÑ Exemplo de RLock (Reentrant Lock)...")

        rlock = asyncio.Lock()  # asyncio.Lock j√° √© reentrant

        async def recursive_function(name: str, depth: int):
            """Fun√ß√£o que chama a si mesma, demonstrando reentr√¢ncia."""
            async with rlock:
                print(f"üîì {name} n√≠vel {depth} - lock adquirido")
                if depth > 0:
                    await asyncio.sleep(0.1)
                    await recursive_function(name, depth - 1)
                print(f"üîì {name} n√≠vel {depth} - lock liberado")

        async with asyncio.TaskGroup() as tg:
            tg.create_task(recursive_function("Task A", 3))
            tg.create_task(recursive_function("Task B", 2))

        print("‚úÖ RLock demonstrado com sucesso!")

    @staticmethod
    async def semaphore_example():
        """Exemplo de Semaphore para limitar concorr√™ncia."""
        print("\nüö¶ Exemplo de Semaphore...")

        # Sem√°foro permite apenas 3 tasks simult√¢neas
        semaphore = asyncio.Semaphore(3)

        async def worker_with_semaphore(name: str, work_time: float):
            """Worker que usa sem√°foro para limitar concorr√™ncia."""
            async with semaphore:
                print(
                    f"üö¶ {name} adquiriu sem√°foro (slots dispon√≠veis: {semaphore._value})",
                )
                await asyncio.sleep(work_time)
                print(f"üö¶ {name} liberou sem√°foro")
                return f"Trabalho de {name} conclu√≠do"

        # Criar 6 workers, mas apenas 3 podem rodar simultaneamente
        tasks = []
        async with asyncio.TaskGroup() as tg:
            for idx in range(6):
                task = tg.create_task(
                    worker_with_semaphore(f"Worker{idx + 1}", 1.0 + idx * 0.2),
                )
                tasks.append(task)

        results = [task.result() for task in tasks]
        print(f"üìä Resultados: {results}")
        return results

    @staticmethod
    async def event_example():
        """Exemplo de Event para sincroniza√ß√£o entre tasks."""
        print("\nüéØ Exemplo de Event...")

        # Event para sinalizar que uma condi√ß√£o foi atendida
        ready_event = asyncio.Event()
        results = []

        async def producer():
            """Producer que prepara dados e sinaliza quando pronto."""
            print("üè≠ Producer iniciando prepara√ß√£o...")
            await asyncio.sleep(2.0)  # Simula prepara√ß√£o
            print("üè≠ Producer sinalizando que est√° pronto!")
            ready_event.set()

        async def consumer(name: str):
            """Consumer que aguarda o producer estar pronto."""
            print(f"üë§ {name} aguardando producer...")
            await ready_event.wait()
            print(f"üë§ {name} recebeu sinal, processando...")
            await asyncio.sleep(0.5)
            results.append(f"Dados processados por {name}")

        async with asyncio.TaskGroup() as tg:
            tg.create_task(producer())
            tg.create_task(consumer("Consumer A"))
            tg.create_task(consumer("Consumer B"))
            tg.create_task(consumer("Consumer C"))

        print(f"üìä Resultados: {results}")
        return results

    @staticmethod
    async def condition_example():
        """Exemplo de Condition para sincroniza√ß√£o complexa."""
        print("\nüîê Exemplo de Condition...")

        # Condition para coordenar acesso a um buffer
        condition = asyncio.Condition()
        buffer: list[str] = []
        max_size = 3

        async def producer_condition(name: str):
            """Producer que aguarda espa√ßo no buffer."""
            for idx in range(3):
                async with condition:
                    # Aguardar at√© ter espa√ßo no buffer
                    while len(buffer) >= max_size:
                        print(f"üè≠ {name} aguardando espa√ßo no buffer...")
                        await condition.wait()

                    item = f"Item{idx} de {name}"
                    buffer.append(item)
                    print(f"üè≠ {name} adicionou {item}, buffer: {buffer}")
                    condition.notify()  # Notificar consumers

                await asyncio.sleep(0.3)

        async def consumer_condition(name: str):
            """Consumer que aguarda itens no buffer."""
            for idx in range(3):
                async with condition:
                    # Aguardar at√© ter itens no buffer
                    while len(buffer) == 0:
                        print(f"üë§ {name} aguardando itens no buffer...")
                        await condition.wait()

                    item = buffer.pop(0)
                    print(f"üë§ {name} consumiu {item}, buffer: {buffer}")
                    condition.notify()  # Notificar producers

                await asyncio.sleep(0.4)

        async with asyncio.TaskGroup() as tg:
            tg.create_task(producer_condition("Producer A"))
            tg.create_task(consumer_condition("Consumer A"))

        print(f"üìä Buffer final: {buffer}")
        return buffer

    @staticmethod
    async def barrier_example():
        """Exemplo de Barrier para sincroniza√ß√£o de m√∫ltiplas tasks."""
        print("\nüöß Exemplo de Barrier...")

        # Barrier que aguarda 3 tasks chegarem
        barrier = asyncio.Barrier(3)

        async def worker_with_barrier(name: str, work_time: float):
            """Worker que aguarda todos chegarem na barrier."""
            print(f"üë∑ {name} iniciando trabalho...")
            await asyncio.sleep(work_time)
            print(f"üë∑ {name} chegou na barrier, aguardando outros...")

            try:
                await barrier.wait()
                print(f"üéâ {name} passou pela barrier! Todos chegaram!")
            except asyncio.BrokenBarrierError:
                print(f"‚ùå {name} - Barrier foi quebrada!")

        async with asyncio.TaskGroup() as tg:
            tg.create_task(worker_with_barrier("Worker A", 0.5))
            tg.create_task(worker_with_barrier("Worker B", 1.0))
            tg.create_task(worker_with_barrier("Worker C", 1.5))

        print("‚úÖ Barrier conclu√≠da com sucesso!")

    @staticmethod
    async def queue_example():
        """Exemplo de Queue para comunica√ß√£o entre tasks."""
        print("\nüì¶ Exemplo de Queue...")

        # Queue para comunica√ß√£o producer-consumer
        queue: asyncio.Queue[str | None] = asyncio.Queue(maxsize=3)
        results = []

        async def producer_queue(name: str, items: int):
            """Producer que coloca itens na queue."""
            for i in range(items):
                item = f"Item{i} de {name}"
                await queue.put(item)
                print(f"üè≠ {name} colocou {item} na queue (tamanho: {queue.qsize()})")
                await asyncio.sleep(0.2)

            # Sinalizar fim
            await queue.put(None)
            print(f"üè≠ {name} finalizou")

        async def consumer_queue(name: str):
            """Consumer que retira itens da queue."""
            while True:
                item = await queue.get()
                if item is None:
                    queue.task_done()
                    break

                print(f"üë§ {name} consumiu {item}")
                await asyncio.sleep(0.3)
                results.append(f"{name} processou {item}")
                queue.task_done()

            print(f"üë§ {name} finalizou")

        async with asyncio.TaskGroup() as tg:
            tg.create_task(producer_queue("Producer A", 2))
            tg.create_task(consumer_queue("Consumer A"))

        # Aguardar todas as tasks terminarem
        await queue.join()
        print(f"üìä Resultados: {results}")
        return results


async def demonstrate_locks():
    """Executa todos os exemplos de locks e sincroniza√ß√£o."""
    print("üîí DEMONSTRANDO LOCKS E SINCRONIZA√á√ÉO EM ASYNCIO...")
    print("=" * 60)

    # Executar todos os exemplos
    await AsyncLockExamples.basic_lock_example()
    await AsyncLockExamples.rlock_example()
    await AsyncLockExamples.semaphore_example()
    await AsyncLockExamples.event_example()
    await AsyncLockExamples.condition_example()
    await AsyncLockExamples.barrier_example()
    await AsyncLockExamples.queue_example()

    print("=" * 60)
    print("‚úÖ Todos os exemplos de locks conclu√≠dos!")


if __name__ == "__main__":
    # Executar demonstra√ß√£o dos TaskGroups
    print("üéØ EXECUTANDO EXEMPLOS DE TASK GROUPS...")
    asyncio.run(task_groups())

    print("\n" + "=" * 60 + "\n")

    # Executar demonstra√ß√£o dos Futures
    print("üéØ EXECUTANDO EXEMPLOS DE FUTURES...")
    asyncio.run(main_future())

    print("\n" + "=" * 60 + "\n")

    # Executar demonstra√ß√£o dos Locks
    print("üéØ EXECUTANDO EXEMPLOS DE LOCKS...")
    asyncio.run(demonstrate_locks())
